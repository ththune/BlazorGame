@using System.Timers
@using BlazorGame.GameLogic

@implements IDisposable

@code {

    //* Number of rows on the board */
    [Parameter] public int Rows { get; set; } = 30;

    //* Number of columns on the board */
    [Parameter] public int Columns { get; set; } = 30;

    //* The board logic that handles the game state */
    private BoardLogic _board = null!;

    //* The snake logic that handles the snake's movement and state */
    private SnakeLogic _snake = null!;

    //* The position of the food on the board */
    private (int Row, int Column) _foodPosition;

    //* Timer to control the snake's movement */
    private Timer? _timer;

    //* Reference to the board element for focus management */
    private ElementReference _boardRef;

    //* Flag to check if the board has been focused */
    private bool _hasFocused;

    //* Random number generator for food spawning */
    private static readonly Random Random = new();

    //* Initialize the game logic and start the timer */
    protected override void OnInitialized()
    {
        _board = new BoardLogic(Rows, Columns);
        _snake = new SnakeLogic(Rows / 2, Columns / 2);
        SpawnFood();

        _timer = new Timer(200);
        _timer.Elapsed += (_, _) => MoveSnake();

        _timer.Start();
        base.OnInitialized();
    }

    //* Spawn food at a random empty cell on the board */
    private void SpawnFood()
    {
        var emptyCells = _board.GetEmptyCells(_snake.Body);
        _foodPosition = emptyCells[Random.Next(emptyCells.Count)];
    }

    //* Move the snake and let it grow if it has eaten food */
    private void MoveSnake()
    {
        InvokeAsync(() =>
        {
            // Check if the snake has eaten food
            var hasEatenFood = _snake.Head.Row == _foodPosition.Row && _snake.Head.Column == _foodPosition.Column;
            _snake.Move(grow: hasEatenFood);
            // If the snake has eaten food, spawn new food
            if (hasEatenFood) SpawnFood();

            StateHasChanged();
        });
    }

    //* Handle keyboard input to change the snake's direction */
    private void HandleKeyDown(KeyboardEventArgs e)
    {
        Direction? newDirection = e.Key switch
        {
            "ArrowUp" or "w" or "W" => Direction.Up,
            "ArrowDown" or "s" or "S" => Direction.Down,
            "ArrowLeft" or "a" or "A" => Direction.Left,
            "ArrowRight" or "d" or "D" => Direction.Right,
            _ => null
        };

        if (newDirection.HasValue) _snake.ChangeDirection(newDirection.Value);
    }

    //* Focus the board element after the first render to enable keyboard input */
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!_hasFocused)
        {
            _hasFocused = true;
            await _boardRef.FocusAsync();
        }
    }

    //* Dispose of the timer when the component is disposed */
    public void Dispose()
    {
        _timer?.Stop();
        _timer?.Dispose();
    }

}

<div class="board" style="--rows: @Rows; --columns: @Columns;" tabindex="0" @onkeydown="HandleKeyDown" @ref="_boardRef">
    @for (var row = 0; row < _board.Rows; row++)
    {
        <div class="board-row">
            @for (var column = 0; column < _board.Columns; column++)
            {
                var snakeClass = BoardLogic.IsSnakeCell(row, column, _snake.Body) ? "snake-cell" : "";
                var foodClass = BoardLogic.IsFoodCell(row, column, _foodPosition) ? "food-cell" : "";
                <div class="board-cell @snakeClass @foodClass"></div>
            }
        </div>
    }
</div> 

